# 求解最小生成树## 1.破圈?原理：树是一个没有环的图，因此将一个拓扑的环全部破掉就生成了树，求解最小生成树，就要把每一个环中最大权值的边去除，剩下的小权值的边之和就是最小的?时间复杂度：在没有进行优化的时候为O(n^3^)，效率很?伪代码：（tupo是邻接矩阵）~~~creturn_type func_name(tupo){    while(有环)    {        去掉环中权值最大的边（修改tupo?       	找环（回溯函数）	}    return tupo;}~~~或者转换思路，从权值最大的边开始去除边，每去除一个边，就判断剩余的图是否连通，如果依然连通就继续去除下一条边，如果不连通，则证明此条边是割边，不可以去除，将此边添加回去，然后去除下一条边，如此循环，直到边数=点数-1（最小生成树的性质?~~~C#include<stdio.h>// #define n 5 int a[n][n]; int flag,am,p,q; void INPUT() {     int i,j;     printf("输入图的带权邻接矩阵：\n");     for(i = 0;i<n;i++)     {         for(j=0;j<n;j++)         scanf_s("%d",&a[i][j]);     }  }   void OUTPUT(int a[n][n])  {      int i,j;      for(i=0;i<n;i++)      {          for(j=0;j<n;j++)          printf("%5d",a[i][j]);          printf("\n");      }  } void  MAX(int a1[n][n],int am1,int p1,int q1)  {	//	a[n][n]:带权图的邻接矩阵, a[i][j] = w或a[i][j] = 0?	//	//	 max : 标记当前找到的准备删去的边的权值；	//	//	 p : 标记找到的要删去的权值所在的行号?	//	//	 q : 标记找到的要删去的权值所在的列好?	//	//	 am：标记找到的最大元素（am是为了保护权值大但不能删的边），如果a[i][j]不能删除，则可以让a[p][q] = am，a[q][p] = am来还原刚才删去的边；      int i,j,ptm,qtm;      int max;      max = 0;      for(i=0;i<n;i++)      {          for(j=i;j<n;j++)          if( (a1[i][j]>max) && (a1[i][j]<=am1) && ((i!=p1)||(j!=q1)) )          {              max = a1[i][j];              ptm = i;              qtm = j;          }      }     am = max;     printf("max=%5d\t",am);      p = ptm;      q = qtm;      a[p][q]=0;//a是全局数组      a[q][p]=0;  } int  WSHALL(int array[n][n])  {	 //华沙尔算法，确定图是否可联?	 //依次遍历邻接矩阵中的所有元素（M[i,j]），比如按照先列后行进行，如果M[i，j] ? 0，那么就把i行加到第j行上?      int i,j,k,m=0;      bool B[n][n];      for(i=0;i<n;i++)      {          for(j=0;j<n;j++)          {              //分界?              if(array[i][j]>=1)                 B[i][j]=1;             else                  B[i][j]=0;              //分界?          }      }	  for (int i = 0; i < 5; i++)	  {		  for (int j = 0; j < 5; j++)		  {			  if (a[i][j] != 0)			  {				  for (int k = 0; k < 5; k++)				  {					  B[i][k] =  B[j][k]=1;					  //此处是矩阵的一些性质，称之为华沙尔算?					  //深度优先，广度优先，并查集都可以完成此处的任?					  //此处我认为可以通过并查集算法来快速确定B矩阵是否是连通的					  //如果连通的话返?，不连通的话返?，效率更?				  }			  }		  }	  }	  printf("B\n");	  for (int i = 0; i < 5; i++)	  {		  for (int j = 0; j < 5; j++)		  {			  printf("%d", B[i][j]);		  }		  printf("\n");	  }     for(i=0;i<n;i++)     {         for(j=0;j<n;j++)             if(!B[i][j])             {                 return 0;                 }     }     return 1; }   int main() {     int i,j,sm,wt=0;     am = 10000,p=-1,q=-1,sm=0;     INPUT();     for(i=0;i<n;i++)     {         for(j=i;j<n;j++)         {             if(a[i][j]>0)                 sm = sm+1;         }     }     printf("\nsm=%d\n",sm);     printf("输出图的带权邻接矩阵：\n");     OUTPUT(a);     printf("\n");     while(sm>n-1)     {         MAX(a,am,p,q);         flag=WSHALL(a);//华沙尔算法判断是否连?         {             if(flag==1)				 //如果连通，则将边数减一             {                 sm=sm-1;                              }                         else             {				 //否则，退回一?                 a[p][q]=am;                 a[q][p]=am;             }         }     }     for(i=0;i<n;i++)     for(j=i;j<n;j++)     {         wt=wt+a[i][j];     }     printf("\n\n输出最小生成树的带权邻接矩阵：\n");     OUTPUT(a);     printf("最小生成树的树权是: %d\n",wt); }      ~~~## 2.Prim?1.用两个集合A{}，B{}分别表示找到的点集和未找到的点集2.以A中的点为起点a，在B‘中找一个点为终点b，这两个点之间的权值需要是其余边中最小的3.重复步骤2，直到B中的点集为空算法的总体思路为贪心算法，每次找未添加的边中权值最小的边，最后得到的生成树一定是最小生成树时间复杂度为O(V^2^)，V为顶点数因为Prim算法的时间复杂度与边数没有关系，所以适合处理稠密?而如果使用较为复杂的斐波那契堆，则可将运行时间进一步缩短为O(E+VlogV)，这在连通图足够密集时（当E满足Ω（VlogV）条件时），可较显著地提高运行速度?~~~c#include <stdio.h>#define MAX 100#define INF 0x3f3f3f3fint graph[MAX][MAX];int Prim(int graph[][MAX], int n){    int lowcost[MAX], mst[MAX];    /*        lowcost[i]记录以i为终点的边的最小权值，当lowcost[i]=0时表示终点i加入生成?        mst[i]记录对应lowcost[i]的起点，当mst[i]=0时表示起点i加入生成?    */    int i, j, min, minid, sum = 0;    for (i = 2; i <= n; i++)  //默认选择1号节点加入生成树，从2号节点开始初始化    {        lowcost[i] = graph[1][i];  //最短距离初始化为其他节点到1号节点的距离        mst[i] = 1;  //标记所有节点的起点皆为默认?号节?    }    mst[1] = 0;  //标记1号节点加入生成树    for (i = 2; i <= n; i++)  //n个节点至少需要n-1条边构成最小生成树    {        min = INF;        minid = 0;        for (j = 2; j <= n; j++)  //找满足条件的最小权值边的节点minid        {            if (lowcost[j] < min && lowcost[j] != 0)  //边权值较小且不在生成树中            {                min = lowcost[j];                minid = j;            }        }        printf("%c - %c : %d\n", mst[minid] + 'A' - 1, minid + 'A' - 1, min);  //输出生成树边的信?起点，终点，权?        sum += min;  //累加权?        lowcost[minid] = 0;  //标记节点minid加入生成?        for (j = 2; j <= n; j++)  //更新当前节点minid到其他节点的权?        {            if (graph[minid][j] < lowcost[j])  ///发现更小的权?            {                lowcost[j] = graph[minid][j];  //更新权值信?                mst[j] = minid;  //更新最小权值边的起?            }        }    }    return sum;  //返回最小权值和}int main(){    int m, n, weight;    char chx, chy;    scanf("%d %d", &m, &n);  //读取节点和边的数?    getchar();    for (int i = 1; i <= m; i++)  //初始化图，所有节点间距离为无穷大        for (int j = 1; j <= m; j++)            graph[i][j] = INF;    for (int k = 0; k < n; k++)  //读取边信?    {        scanf("%c %c %d", &chx, &chy, &weight);        getchar();        int i = chx - 'A' + 1, j = chy - 'A' + 1;  ///ABCDEF        graph[i][j] = weight;        graph[j][i] = weight;    }    printf("Total: %d\n", Prim(graph, m));    return 0;}~~~## 3.Kruskal<1>　设一个有n个顶点的连通网络为G（V,E），最初先构造一个只有n个顶点，没有边的非连通图T={V,空}，图中每个顶点自成一格连通分量?<2>　在Ｅ中选择一条具有最小权植的边时，若该边的两个顶点落在不同的连通分量上，则将此边加入到Ｔ中；否则，即这条边的两个顶点落到同一连通分?   上，则将此边舍去（此后永不选用这条边），重新选择一条权植最小的边?<3>　如此重复下去，直到所有顶点在同一连通分量上为止?在进行第二步的时候，可以使用并查集算法，时间复杂度为：O(nlogn)基本的处理思想是：初始时把每个对象看作是一个单元素集合；然后依次按顺序读入联通边，将连通边中的两个元素合并。在此过程中将重复使用一个搜索（Find）运算，确定一个集合在那个集合中。当读入一个连通边（ｕ，ｖ）时，先判断ｕ和ｖ是否在同一个集合中，如果是则不用合并；如果不是，则用一个合并（Union）运算把ｕ、ｖ所在集合合并，使得这两个集合中的任意两个元素都连通。因此并查集在处理时，主要用到搜索和合并两个运算?~~~c #include <stdio.h> #include <string.h> #include <algorithm> #define MAXN 11  //顶点个数的最大? #define MAXM 20  //边的个数的最大? using namespace std;   struct edge  //? {     int u, v, w; //边的顶点、权? }edges[MAXM]; //边的数组  int parent[MAXN];  //parent[i]为顶?i 所在集合对应的树中的根结点 int n, m;  //顶点个数、边的个? int i, j;  //循环变量 void UFset( )  //初始? {     for( i=1; i<=n; i++ )          parent[i] = -1; } int Find( int x ) //查找并返回节?x 所属集合的根结? {     //非递归的并查集搜索算法，在数据规模比较小的时候可以使用递归算法，可以使代码更简?     //此处如果数据规模不大的话，可以考虑使用递归的搜索方?     int s; //查找位置     for( s=x; parent[s]>=0; s=parent[s] );     while( s!=x ) //优化方案―压缩路径，使后续的查找操作加速?     {         int tmp = parent[x];         parent[x] = s;         x = tmp;     }     return s; }  //将两个不同集合的元素进行合并，使两个集合中任两个元素都连? void Union( int R1, int R2 ) {          int r1 = Find(R1), r2 = Find(R2); //r1 ?R1 的根结点，r2 ?R2 的根结点     int tmp = parent[r1] + parent[r2]; //两个集合结点个数之和(负数)     //如果 R2 所在树结点个数 > R1 所在树结点个数(注意 parent[r1]是负?     if( parent[r1] > parent[r2] ) //优化方案――加权法?     {         parent[r1] = r2;          parent[r2] = tmp;     }     else     {         parent[r2] = r1;          parent[r1] = tmp;     } } bool cmp( edge a, edge b ) //实现从小到大排序的比较函? {     return a.w <= b.w; } void Kruskal( ) {     int sumweight = 0;  //生成树的权?     int num = 0;  //已选用的边的数?     int u, v;  //选用边的两个顶点     UFset( ); //初始?parent[]数组     for( i=0; i<m; i++ )     {         u = edges[i].u; v = edges[i].v;         if( Find(u) != Find(v) )         {             printf( "%d %d %d\n", u, v, edges[i].w );             sumweight += edges[i].w; num++;             Union( u, v );         }         if( num>=n-1 ) break;     }     printf( "weight of MST is %d\n", sumweight ); } int main( ) {     int u, v, w; //边的起点和终点及权?     scanf( "%d%d", &n, &m ); //读入顶点个数 n     for( int i=0; i<m; i++ )     {     scanf( "%d%d%d", &u, &v, &w ); //读入边的起点和终?     edges[i].u = u; edges[i].v = v; edges[i].w = w;     }     sort(edges,edges+m,cmp);     Kruskal();     return 0; }~~~## 3.Boruvka算法?所有当前的连通块向其他连通块扩展出最小边*，直到只剩一个连通块”，其中取最小边的贪心思想?Kruskal 的主体，而向外扩展又?Prim 的思想 —?基于另外两种生成树算法，Boruvka 的正确性显然?伪代码：~~~cwhile 连通块个数>1    for 每个连通块 i        mn[i] = 连接 i 与其他连通块的最小边    for 每个连通块 i        if mn[i] 连接两个不同的连通块            ans += mn[i]            Merge( mn[i] 连接的连通块 )            连通块个数 --~~~其中最为重要的是求 `mn[i]`，可能会以其他各种算法辅助求解，提高效率由于每进行一次操作，连通块个数会减少一半，因此（如果记 O(T) 是计?`mn[]` 的复杂度）这个算法的复杂度是 O(Tlog~2~⁡N)。最朴素的求 `mn[]` 的方法是 O(M) 枚举边，如果可以优化这一步骤，效率会大大提高?因为当输入的无权图接近一个完全图的时候，在mn[]这一步时间复杂度将会是O(n^2^)，总的时间复杂度将会是O(n^2^long~2~n)，效率将会下降到无法忍受的情?代码实现~~~c#include<bits/stdc++.h>using namespace std;const int M =4e5+7;const int N =5050;struct node{	int nxt,w,to;//nxt起点，w权重，to终点 }ee[M];//边集 int head[M],cnt;void add(int u,int v,int w){	ee[++cnt].to=v;	ee[cnt].w=w;	ee[cnt].nxt=head[u];	head[u]=cnt;}int fa[N],siz[N];int get(int x)//寻找该节点的父节?{	if(x==fa[x])return x;	return fa[x]=get(fa[x]);}void merge(int x,int y){	int gx=get(x),gy=get(y);	if(siz[gx]>siz[gy])		fa[gy]=gx,siz[gx]+=siz[gy];	else fa[gx]=gy,siz[gy]+=siz[gx];}int Boruvka(int n){	int ans=0;		//ans最小生成树权重?	int link[N],val[N];	//某个联通块的祖先，最小的外出边权，连向link，边权是val?	bool f=true;		//联通块是否大于1 	while(f)			//每次联通块减半，这一步最多logn?	{		memset(link,0,sizeof(link));		memset(val,0x3f,sizeof(val));				for(int i=1;i<=n;i++)		{			int u=i;			int gu=get(u);						for(int j=head[i];j;j=ee[j].nxt)			{				int v=ee[j].to,w=ee[j].w;				int gv=get(v);								if(w>=val[gu]||gu==gv)continue;//这个边权不是最小，或者这条边在一个联通块内?				val[gu]=w,link[gu]=gv;//gu所在联通块与gv所在联通块，通过 j这条边连接局部最?			}		}		for(int i=1;i<=n;i++)		{			int gi=get(i);			if(gi!=i)continue;//以联通块为单位进行处?			int v=link[gi];			int gv=get(v);			if(v&&gv!=gi)merge(gv,gi),ans+=val[gi];		}		int nm=0;		for(int i=1;i<=n;i++)if(get(i)==i)nm++;		if(nm==1)f=false;	}	return ans;}int main(){	int n,m,u,v,w;	scanf("%d%d",&n,&m);	for(int i=1;i<=m;i++)		scanf("%d%d%d",&u,&v,&w),add(u,v,w),add(v,u,w);	for(int i=1;i<=n;i++)		fa[i]=i,siz[i]=1;	printf("%d\n",Boruvka(n));	return 0; } ~~~## 5.DNA算法（k-臂DNA计算模型?1999，Jonoska 等人提出来的一种DNA计算模型K-臂模?K-臂DNA 分子的结构可以看出，通过连接酶，我们可以利用K-臂（K?）DNA 分子构造出任意顶点的最大度? 的图。正是利用这一思想，我们用K-臂分子来表示图或树中度为n（n?）的顶点的结构，来实现最小生成树问题解的节点结构。在求解最小生成树问题计算模型的编码方案中，使用的DNA 分子是由单链和双链进行混合编码的不完全分子?<img src="C:\Users\苍玄\AppData\Roaming\Typora\typora-user-images\image-20211202180814721.png" alt="image-20211202180814721" style="zoom:100%;" />DNA算法是通过DNA 分子之间的生化反应来进行计算的一种计?模式。DNA计算将具有以下几个方面的突出优点:(l)具有高度?并行性，运算速度快?2)DNA作为信息的载体其贮存的容量非常之大?3)DNA计算机所消耗能量极小?4)DNA分子的资源丰富。算法的总的计算量为n-1?## 4.总结以搜集到的资料来看，Kruskal算法的描述比较简单，而且好i理解，同时此算法的优化已经十分完备，但是由于此算法注重边的计算，所以当图为稠密图的时候，时间效率将会不敌Prim算法Prim算法在稀疏图的表现相较于Kruskal算法更差一点，但是在稠密图的计算中表现良好前两个算法都是基于贪心的策略，从局部最优到全局最?Boruvka算法可以视作Kruskal和Prim算法的结合版，Boruvka 算法的一句话思想便是?“从*所有当前的连通块向其他连通块扩展出最小边*，直到只剩一个连通块”，其中取最小边的贪心思想?Kruskal 的主体，而向外扩展又?Prim 的思想 —?基于另外两种生成树算法，Boruvka 的正确性显然?而对于破圈法，前三个算法的思想都是避圈法，即建立一个空图，然后按顺序添加边或点，直到将所有点全部添加进新的图中，而破圈法是反过来的，破圈法在保证图是连通图的情况下将所有权重大的边全部删除，最终也得到了最小生成树，但是因此也造成了该法时间效率的低下O(n^3^)的时间复杂度，即使经过优化也很难与前三个算法匹敌，可以作为了?而DNA算法在目前的电子计算机上进行模拟反而效果很差，此算法基于DNA计算，效率很高，但是目前很难实现，我们组目前只在一些论文中找到了关于该算法的描?